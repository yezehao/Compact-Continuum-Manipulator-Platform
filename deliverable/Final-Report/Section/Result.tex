%%%%% Result and Discussion %%%%%
\section{Result and Discussion} 
\subsection{Error Analysis of Cross-Shaped Sheets}
At the early stage of the project, given that the number of cross-shape sheets in each modules may have an 
influence on the maximum bending angle $\boldsymbol{\alpha}_{max}$, which is an essential parameter of those which 
affect the range of working space of the manipulator, hence the number of sheets should be determined by deriving 
the functions of both absolute error and relative error \cite{fishboneCR} against the number of sheets. The 
simulation results are shown in Figure \ref{fig:error_analysis}.
\begin{figure}[H] %[H] "corresponds to start the figure Here" 
    \centering %alignment can be flushleft or flushright
    \captionsetup{labelsep=colon}
    \includegraphics[width=0.75\textwidth]{Image/Result/error_analysis.png} 
    \caption[The simulation results of errors against the number of connecting sheets]
    {\centering \textbf{The simulation results of errors against the number of connecting sheets.}}
    \label{fig:error_analysis}
\end{figure}
As illustrated in Figure \ref{fig:error_analysis}, the changing trends of both absolute and relative errors are 
almost identical since 
the relative error is proportional to the absolute error, and the different lines with different colors represent 
the data with different bending angles whose range is from 10 degrees to 90 degrees in both directions (positive 
or negative). It is obvious that both errors decrease with the increase in the number of connecting sheets, hence 
theoretically, the number of sheets should be as large as possible to make both errors could be negligible. However, 
the number of sheets also has an influence on the size of simulation space, more the number of sheets less the size 
of simulation space given that if the length of manipulator is much longer, the space near to the basement of 
manipulator could not be reached due to the characteristics of the material. Hence, the number of sheets could be 
assumed to be 10 rather than 15, even though both the errors are smaller when the number of sheets is 15. \\
\subsection{Manipulator Workspace Analysis}
The workspace simulation of the manipulator has been illustrated since it is important to determine the 
variables of joints based on the required workspace. The segmented workspace is affected by several aspects, 
which include the simulation index and the range within the three-dimensional coordinates. The effective workspace 
of the manipulator is a cubic whose dimension is 300x300x300 (mm). The specific workspace has a fixed range on 
the x and y axes from -150 to 150 mm. Therefore, it is only necessary to determine the range of the workspace 
along the z-axis. The parameter H, representing the height of the basement of specific workspace, is 
utilized to determine the range of the workspace along the z-axis. The impacts of different indices and 
parameter H will be discussed separately, aiming to segment the appropriate cubic worksapce of the manipulator.
\begin{figure}[H] %[H] "corresponds to start the figure Here" 
    \centering %alignment can be flushleft or flushright
    \captionsetup{labelsep=colon}
    \begin{subfigure}{0.45\textwidth} % subfigure 1
        \centering
        \includegraphics[width=\linewidth]{Image/Result/workspace_10000.png}
        \caption{\centering The entire workspace where simulation index=10000}
        \label{fig:ws_10000}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth} % subfigure 2
        \centering
        \includegraphics[width=\linewidth]{Image/Result/workspace_1000000.png}
        \caption{\centering The entire workspace where simulation index=1000000}
        \label{fig:ws_1000000}
    \end{subfigure}
    \caption[The entire workspace with different random indices]
    {\centering \textbf{The entire workspace with different simulation indices.}}
    \label{fig:ws_diff}
\end{figure}
\noindent As shown in Figure \ref{fig:ws_10000}, the working space of manipulator forms a spherical shell-shaped 
point cloud consisting of 10000 floating points since the simulation index is 10000, which is insufficient to fully 
occupied the theoretical workspace. To further generalize the theoretical workspace, it is necessary to increase 
the simulation index. The appropriate workspace should be divided from the workspace whose index is 1000000. 
\begin{figure}[H] %[H] "corresponds to start the figure Here" 
    \centering %alignment can be flushleft or flushright
    \captionsetup{labelsep=colon}
    \begin{subfigure}{0.45\textwidth} % subfigure 2
        \centering
        \includegraphics[width=\linewidth]{Image/Result/rect_workspace_1000000_350-650.png}
        \caption{\centering The cubic workspace of manipulator with index = 1000000 H=350-650mm}
        \label{fig:ws_1000000_350}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.45\textwidth} % subfigure 1
        \centering
        \includegraphics[width=\linewidth]{Image/Result/rect_workspace_1000000_300-600.png}
        \caption{\centering index = 1000000 H=300-600mm}
        \label{fig:ws_10000_300}
    \end{subfigure}
    \caption[The cubic workspace with different segmentation]
    {\centering \textbf{The cubic workspace with different segmentation.}}
    \label{fig:ws_300_350}
\end{figure}
Comparing the simulation results illustrated in Figure \ref{fig:ws_300_350}, it can be observed that the upper 
area of the segmented cubic workspace whose H=350mm failed to be occupied. However, the segmented cubic workspace 
whose H=300mm is almost fully occupied. To determine threshold of parameter H, a series of yellow detection points 
are utilized to test whether specific locations in the workspace can be reached. A programme is utilized to calculate 
the distance between the detection points and the simulated point cloud and identify the minimum distances. The  
simulation results whose index=1000000 and H=300mm are shown in Figure \ref{fig:matlab_300} in Appendix 
\ref{append:code_display}. The top view of the cubic workspace in Figure \ref{fig:top_view} associates labels with 
detection points, facilitating subsequent explanations. 
\begin{figure}[H] %[H] "corresponds to start the figure Here" 
    \centering %alignment can be flushleft or flushright
    \captionsetup{labelsep=colon}
    \includegraphics[width=0.75\textwidth]{Image/Result/top_view_rect_workspace.png} 
    \caption[The top view of the workspace and the labels of detection points]
    {\centering \textbf{The top view of the workspace and the labels of detection points.}}
    \label{fig:top_view}
\end{figure}
While H=300 mm, The heights of the first, second, third, and fourth layers are 300 mm, 400 mm, 500 mm, and 600 mm, 
respectively. As the second and third layers are situated in the middle, theoretically all detection points on 
these two layers are reachable. Therefore, the mean and variance of distances to these points can be calculated. 
Combined with a normal distribution whose $\mu = 0$, a threshold is set to be 99.7\% of the data are within 3 
standard deviations of the mean can be derived to determine whether detection points on the first and fourth 
layers are reachable. The threshold $\tau$ can be calculated in Equation \ref{eq:threshold_reachable}. \\
\begin{align}
    &\bar{d}_{2,3} = \sum_{i=2}^3 \sum_{j=1}^9 d_{ij,min} \nonumber \\
    &\sigma_{2,3}=\sqrt{\dfrac{1}{n}\times\sum_{i=1}^n(d_i-\bar{d})^2} \nonumber \\
    &\tau = \bar{d}_{2,3} + 3\times\sigma_{2,3}
    \label{eq:threshold_reachable}
\end{align}
The segmentation of the effective workspace for other values of H, specifically H=240, 260, and 280 mm, 
can also be performed using the same approach. The numerical values corresponding to different H parameters 
are illustrated in Figures \ref{fig:matlab_240}, \ref{fig:matlab_260}, \ref{fig:matlab_280} in Appendix 
\ref{append:code_display}. The results and reachability for different H are presented in Table 
\ref{tab:threshold_and_reachability}.
\begin{center}
    \small
    \begin{longtable}{l l l l l l }
    \caption{The Reachability of Detection Points with Different H.} \label{tab:threshold_and_reachability} \\
    \hline \multicolumn{1}{l}{\textbf{H (mm)}} & 
    \multicolumn{1}{l}{\textbf{Layer}} & 
    \multicolumn{1}{l}{\textbf{$\bar{d}_{2,3}$ (mm)}} & 
    \multicolumn{1}{l}{\textbf{$\sigma_{2,3}$ (mm)}} & 
    \multicolumn{1}{l}{\textbf{Threshold $\tau$ (mm)}} & 
    \multicolumn{1}{l}{\textbf{Reachability}} \\ \hline 
    \endfirsthead
    \multicolumn{6}{c}%
    {{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
    \hline \multicolumn{1}{l}{\textbf{H (mm)}} & 
    \multicolumn{1}{l}{\textbf{Layer}} & 
    \multicolumn{1}{l}{\textbf{$\bar{d}_{2,3}$}} & 
    \multicolumn{1}{l}{\textbf{$\sigma_{2,3}$}} & 
    \multicolumn{1}{l}{\textbf{Threshold $\tau$}} & 
    \multicolumn{1}{l}{\textbf{Reachability}} \\ \hline 
    \endhead
    \hline \multicolumn{6}{|r|}{{Continued on next page}} \\ \hline
    \endfoot
    \hline \hline
    \endlastfoot
    % table context
    300&1&5.79 & 2.50 & 13.29 &9 \\
       &4&5.79 & 2.50 & 13.29 &3 \\
    280&1&4.87 & 2.02 & 10.94 &9 \\
       &4&4.87 & 2.02 & 10.94 &4 \\
    260&1&5.37 & 2.01 & 11.41 &7 \\
       &4&5.37 & 2.01 & 11.41 &7 \\
    240&1&5.35 & 2.48 & 12.78 &8 \\
       &4&5.35 & 2.48 & 12.78 &9 \\
    \hline
    % \multirow{2}{*}{3D cartesian/gantry manipulator} & PPP & 3 & 1   \\
    % & & & \\ \hline
    \end{longtable}
\end{center}
As shown in Table \ref{tab:threshold_and_reachability}, setting H to 240 mm achieves better reachability, 
which is more reasonable compared to other scenarios. Additionally, to obtain a more accurate threshold, 
multiple tests or experimenting with a greater number of simulation indices can be undertaken to reduce random 
and systematic errors.
\subsection{Inverse Kinematics} % Done by Zehao Ye
This section will demonstrate the singular posture solution and trajectory replication results of the inverse 
kinematics algorithm. A comprehensive analysis of its accuracy and computational speed will be conducted, along 
with a description of its advantages and limitations. To begin with, it is essential to note that using angles 
as input for the programme is feasible due to the relative complexity of specifying the $\textbf{O}_{target}$ 
and $\textbf{P}_{target}$, which involves a total of 12 parameters. Moreover, the targets are generated based 
on angles by forward kinematics algorithm during the test. In essence, there is no substantial distinction 
between inputting angles and inputting coordinates.
\subsubsection{Singular Posture Solution}
Firstly, the bending of individual modules was tested as the target for the inverse kinematics solution. The 
inverse kinematics algorithm was tested for different angles of bending for Module 1, 2, 3, and 4, and the 
specific results are presented in Table \ref{tab:single_posture_IK} in Appendix \ref{append:table}. The 
solutions about the Modules 3 and 4 are highly satisfactory, with Module 3 even converging to error of 0.02mm 
in 6 epochs. However, the bending results for Module 1 and 2 are unsatisfied, which is caused by inappropriate 
initialization. According to the flowchart in Figure \ref{fig:flowchart}, the FABRIKc algorithm requires an 
initialization to start iterations. Taking the example of the target with 
$\boldsymbol{\alpha} = [0,\ 90,\ 0,\ 0]\degree$, after initializing with the initial posture in Figure 
\ref{fig:kinematics model 0_0_0_0} and applying the FABRIKc algorithm for iterations, the first iteration yields 
a posture with 
$\boldsymbol{\theta} = [-0.0,\ 104.04,\ -0.0,\ -22.0]\degree$. Moreover, since each iteration starts from Module 4, the error 
in Module 4 cannot be eliminated and persists. To mitigate this effect, selecting a more suitable posture for 
initialization is crucial, which can be solved trajectory replication. If the posture used for initialization with 
$\boldsymbol{\alpha} = [0,\ 100,\ 0,\ 0]\degree$, the solution of inverse kinematics algorithm would be 
$\boldsymbol{\theta} = [-0.0,\ 81.77,\ -0.0,\ 9.3]\degree$. Nevertheless, due to errors generated by the iteration sequence, 
complete elimination remains challenging, and efforts are focused on minimizing them as much as possible. \\
Afterwards, the complex bending angles of modules was utilized to investigate the influences of initialization. 
The target with angles $\boldsymbol{\alpha} = [80,\ 120,\ -120,\ 90]\degree$ is selected because its solution is complex, and 
it lies within the workspace of manipulator. The posture of the manipulator is shown in Figure 
\ref{fig:complex_target}. This scenario is likely to occur in practical applications and necessitates resolution 
through relevant methods.
\begin{figure}[H] %[H] "corresponds to start the figure Here" 
    \centering %alignment can be flushleft or flushright
    \captionsetup{labelsep=colon}
    \begin{subfigure}{0.9\textwidth} % subfigure 1
        \centering
        \includegraphics[width=\linewidth]{Image/MATLAB/manipulator_80_120_-120_90.png}
        \caption{\centering target: $\boldsymbol{\alpha} = [80,\ 120,\ -120,\ 90] \degree$ \\ \qquad}
        \label{fig:complex_target}
    \end{subfigure}
    \begin{subfigure}{0.49\textwidth} % subfigure 2
        \centering
        \includegraphics[width=\linewidth]{Image/MATLAB/manipulator_-8.88_-89.99_-126.81_-169.73.png}
        \caption{\centering initialization: $\boldsymbol{\alpha} = [0, 0, 0, 0]\degree$; \\
        $\boldsymbol{\theta} = [-8.88,\ -89.99,\ -126.81,\ -169.73]\degree$ }
        \label{fig:complex_init_0_0_0_0}
    \end{subfigure}
    \begin{subfigure}{0.49\textwidth} % subfigure 3
        \centering
        \includegraphics[width=\linewidth]{Image/MATLAB/manipulator_84.98_122.93_-114.9_63.01.png}
        \caption{\centering initialization: $\boldsymbol{\alpha} = [85, 125, -115, 55]\degree$; \\
        $\boldsymbol{\theta} = [84.98,\ 122.93,\ -114.9,\ 63.01]\degree$ }
        \label{fig:complex_init_85_125_-115_55}
    \end{subfigure}
    \caption[The kinematics model of manipulator with respective bending modules]
    {\centering \textbf{The inverse kinematics algorithm with different initialization.}}
    \label{fig:80_120_-120_90_diff_initial}
\end{figure}
\noindent With the initialization using the initial posture, the solution is 
$\boldsymbol{\theta} = [-8.88, -89.99, -126.81, -169.73]\degree$, which is shown in Figure \ref{fig:complex_init_0_0_0_0}. 
However, the solution of inverse kinematics algorithm would be $\boldsymbol{\theta} = [84.98,\ 122.93,\ -114.9,\ 63.01]\degree$, 
which is significantly close to the target while the angles for initialization are $[85,\ 125,\ -115,\ 55]\degree$. 
The solution of the inverse kinematics with more appropriate initialization is shown in Figure 
\ref{fig:complex_init_85_125_-115_55}. This signifies that if the manipulator is presently in a posture similar 
to the target configuration, it can accurately determine the corresponding bending angles $\boldsymbol{\theta}$ through the 
inverse kinematics algorithm. This proves to be highly beneficial for trajectory replication. \\
Ultimately, The efficient computational capability of algorithm is one of its strengths. The algorithm only 
takes 1.905 seconds to complete 10,000 epochs updating. In practical applications, it requires only 200 epochs 
to determine convergence. In comparison to traditional methods like inverse Jacobian \cite{inverse_jacobian}, 
which involve matrix transformations and derivatives, this approach can provide potential solutions in a short 
time, addressing the issue of singular points. However, this method has its limitations. In scenarios with 
multiple segments, the algorithm may introduce significant errors due to the calculation order, and these errors 
can be challenging to eliminate. The only viable solution is to enhance the algorithm's performance through 
careful initialization methods.
\subsubsection{Trajectory Replication}
The preceding discussion has highlighted genetic method, which is utilizing the current posture for 
initialization in trajectory replication. In this phase, the comparison between consistently utilizing the 
initial posture for trajectory replication and using the current posture as the initialization aims to 
highlight the benefits of incorporating genetic method in trajectory replication and planning for the inverse 
kinematics algorithm. Subsequently, the genetic method and inverse kinematics algorithm are employed to 
replicate two types of trajectories: arc segments and closed paths. This section will analyze the genetic 
method and these two trajectories, elucidating the strengths and weaknesses of inverse kinematics algorithm. \\
The blue trajectory displayed in Figure \ref{fig:genetic_approach} is the target trajectory, which bending from 
$\boldsymbol{\alpha} = [0,\ 0,\ 0,\ 0]$ to $\boldsymbol{\alpha} = [20,\ 20,\ 20,\ 20]$ equally in 20 steps. 
The red trajectory represents the replicated trajectory using consistent initialization with the initial 
posture. The purple trajectory depicts the replicated trajectory using the genetic method with initialization 
based on the current posture. The trajectory replication using the genetic method is comparatively better 
aligned with the target. The corrective effectiveness of the genetic algorithm has also been validated for 
other targets. The data of trajectories in Figure \ref{fig:genetic_approach} is listed in Table 
\ref{tab:trajectory_with_without_genetic}.
\begin{figure}[H] %[H] "corresponds to start the figure Here" 
    \centering %alignment can be flushleft or flushright
    \captionsetup{labelsep=colon}
    \includegraphics[width=1.0\textwidth]{Image/Result/trajectory_replication_diff_initialization.png} 
    \caption[The trajectory replications with and without genetic method]
    {\centering \textbf{The trajectory replications with and without genetic method.}}
    \label{fig:genetic_approach}
\end{figure}
\noindent The replicated trajectories of both target trajectories closely align, but there exists a certain degree of error. 
This discrepancy is attributed to the inclusion of an error threshold $\boldsymbol{\epsilon}$ set at 0.02 in the 
programme, allowing for computational efficiency while maintaining accuracy. However, when dealing with significantly 
larger angular deviations, instances may arise where the replicated trajectories failed to precisely match the 
target trajectories. This situation can be overlooked as it falls beyond the defined workspace. The average errors
about the trajectory replication are calculated in Table \ref{tab:traj_average_errors}.
\begin{center}
    \small
    \begin{longtable}{l l l}
    \caption{The Average Errors of the replicated trajectories.} \label{tab:traj_average_errors} \\
    \hline \multicolumn{1}{l}{\textbf{Replicated Trajectory}} & 
    \multicolumn{1}{l}{\textbf{$e_{average}$ (mm)}} & 
    \multicolumn{1}{l}{\textbf{$e_{average}$ (mm)}} \\ \hline 
    \endfirsthead
    \multicolumn{3}{c}%
    {{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
    \hline \multicolumn{1}{l}{\textbf{Replicated Trajectory}} & 
    \multicolumn{1}{l}{\textbf{$e_{average}$ (mm) of Figure \ref{fig:tr_cross}}} & 
    \multicolumn{1}{l}{\textbf{$e_{average}$ (mm) of Figure \ref{fig:tr_cross}}} \\ \hline 
    \endhead
    \hline \multicolumn{3}{|r|}{{Continued on next page}} \\ \hline
    \endfoot
    \hline \hline
    \endlastfoot
    % table context
    \textbf{total}	& 3.576157 & 6.415941 \\
    \textbf{in workspace}	& 1.032255 & 2.642474 \\
    \hline
    % \multirow{2}{*}{3D cartesian/gantry manipulator} & PPP & 3 & 1   \\
    % & & & \\ \hline
    \end{longtable}
\end{center}
\begin{figure}[H] %[H] "corresponds to start the figure Here" 
    \centering %alignment can be flushleft or flushright
    \captionsetup{labelsep=colon}
    \includegraphics[width=1.0\textwidth]{Image/Result/cross_trajectory_replication_with_label.png} 
    \caption[The cross-shaped trajectory and its replication by FABRIKc algorithm]
    {\centering \textbf{The cross-shaped trajectory and its replication.}}
    \label{fig:tr_cross}
\end{figure}
\begin{figure}[H] %[H] "corresponds to start the figure Here" 
    \centering %alignment can be flushleft or flushright
    \captionsetup{labelsep=colon}
    \includegraphics[width=1.0\textwidth]{Image/Result/circle_trajectory_replication_with_label.png} 
    \caption[The closed trajectory and its replication by FABRIKc algorithm]
    {\centering \textbf{The closed trajectory and its replication.}}
    \label{fig:clc_cross}
\end{figure}
\subsubsection{The improvement about Inverse kinematics algorithm}
However, it is challenging to calculate certain postures with inverse kinematics algorithm. A method has 
been proposed involving continuous position updates through a factor $f_u$. Nevertheless, this approach 
lacks systematic validation and is currently feasible only in specific circumstances. Therefore, it is 
mentioned here solely as a potential solution. \\
In practical applications, the initialization can be started with a relatively similar posture 
to move the manipulator to the target. In this context, the target where $\boldsymbol{\theta_{target}}$ = 
[45, 45, -45, -45] $\degree$ and the initialization with $\boldsymbol{\alpha_0}$ = [20, 20, -20, -20] $\degree$ 
is utilized to exemplify the corresponding calculations. The $\boldsymbol{target}$ is the position and 
orientation of the manipulator end effector. \\
The current posture with $\boldsymbol{\alpha_0}$  = [20, 20, -20, -20] $\degree$ is used as an initialization 
for calculations through inverse kinematics algorithm, resulting in the solution $\boldsymbol{\theta_1}$. 
The difference between $\boldsymbol{\alpha_0}$ and $\boldsymbol{\theta_1}$ is calculated by $f_u = 0.5$ to acquire 
$\boldsymbol{\alpha_1}$, which is shown in Equation \ref{eq:alpha_0_to_1}.
\begin{align}
    &\boldsymbol{\theta_1} = \textbf{FABRIKc}(\boldsymbol{target}, \boldsymbol{\alpha_0}) 
    = [42.38, 73.25, -69.59, -62.85]\degree \nonumber \\
    &\boldsymbol{\alpha_1} = \boldsymbol{\alpha_0} + f_u \cdot (\boldsymbol{\theta_1} - \boldsymbol{\alpha_0}) 
    = [31.19, 46.63, -34.80, -41.43]\degree
    \label{eq:alpha_0_to_1}
\end{align}
Subsequently, this process can be repeated, obtaining $\boldsymbol{\theta_2}$ based on $\boldsymbol{\alpha_1}$ in 
Equation \ref{eq:alpha_0_to_1} and then updating $\boldsymbol{\alpha_2}$ in Equation \ref{eq:alpha_1_to_2}.
\begin{align}
    &\boldsymbol{\theta_2} = \textbf{FABRIKc}(\boldsymbol{target}, \boldsymbol{\alpha_1}) 
    = [56.95, 34.48, -56.40, -38.96]\degree \nonumber \\
    &\boldsymbol{\alpha_2} = \boldsymbol{\alpha_1} + f_u \cdot (\boldsymbol{\theta_2} - \boldsymbol{\alpha_1}) 
    = [44.07, 40.56, -45.60, -40.20]\degree
    \label{eq:alpha_1_to_2}
\end{align}
The $\boldsymbol{\alpha_i}$ can be continuously updated according to the method, which the results yield in Equations 
\ref{eq:alpha_2_to_3}, \ref{eq:alpha_3_to_4}, \ref{eq:alpha_4_to_5}, and \ref{eq:alpha_5_to_6}.
\begin{align}
    &\boldsymbol{\theta_3} = \textbf{FABRIKc}(\boldsymbol{target}, \boldsymbol{\alpha_2}) 
    = [43.64, 51.49, -45.97, -48.84]\degree \nonumber \\
    &\boldsymbol{\alpha_3} = \boldsymbol{\alpha_2} + f_u \cdot (\boldsymbol{\theta_3} - \boldsymbol{\alpha_2}) 
    = [43.56, 46.03, -45.79, -44.52]\degree
    \label{eq:alpha_2_to_3}
\end{align}
\vspace{-18mm}
\begin{align}
    &\boldsymbol{\theta_4} = \textbf{FABRIKc}(\boldsymbol{target}, \boldsymbol{\alpha_3}) 
    = [46.22, 42.71, -45.9, -43.88]\degree \nonumber \\
    &\boldsymbol{\alpha_4} = \boldsymbol{\alpha_3} + f_u \cdot (\boldsymbol{\theta_4} - \boldsymbol{\alpha_3}) 
    = [44.89, 44.37, -45.85, -44.20]\degree
    \label{eq:alpha_3_to_4}
\end{align}
\vspace{-18mm}
\begin{align}
    &\boldsymbol{\theta_5} = \textbf{FABRIKc}(\boldsymbol{target}, \boldsymbol{\alpha_4}) 
    = [44.87, 45.23, -45.03, -45.30]\degree \nonumber \\
    &\boldsymbol{\alpha_5} = \boldsymbol{\alpha_4} + f_u \cdot (\boldsymbol{\theta_5} - \boldsymbol{\alpha_4}) 
    = [44.88, 44.80, -45.85, -44.20]\degree
    \label{eq:alpha_4_to_5}
\end{align}
\vspace{-18mm}
\begin{align}
    &\boldsymbol{\theta_6} = \textbf{FABRIKc}(\boldsymbol{target}, \boldsymbol{\alpha_5}) 
    = [45.08, 44.91, -45.09, -44.96]\degree \nonumber \\
    &\boldsymbol{\alpha_6} = \boldsymbol{\alpha_5} + f_u \cdot (\boldsymbol{\theta_6} - \boldsymbol{\alpha_5}) 
    = [44.94, 44.86, -45.47, -44.58]\degree
    \label{eq:alpha_5_to_6}
\end{align}

\noindent In addition, it is possible to manually adjust the manipulator posture visually. While this method is relatively 
straightforward, it lacks precision. It is important to note that due to orientation constraints, the sum of 
angles for modules 1 and 3 and modules 2 and 4 should remain constant during the adjustment process.

\subsection{Electroinc Control}
Initially, the testing of the results was supposed to be carried out through Proteus simulation. However, 
it was discovered that during the simulation process in Proteus, the motor components did not function normally, 
with frequent occurrences of stepping errors. Meanwhile, the simulation could not be completed in real-time 
due to the heavy load on the computer CPU. After consideration, the team members purchased a complete set of real 
components for testing. In the real circuit, the pin that each motor occupies are listed in Table \ref{tab:stepmotor_pin} 
to reduce the complexity of wiring. 
\begin{center}
    \small
    \begin{longtable}{c c c c c c c c c}
    \caption{The Pin Assignment of Stepper Moters.} \label{tab:stepmotor_pin} \\
    \hline \multicolumn{1}{l}{\textbf{Stepper Motor}} & 
    \multicolumn{1}{l}{\textbf{1}} & 
    \multicolumn{1}{l}{\textbf{2}} & 
    \multicolumn{1}{l}{\textbf{3}} & 
    \multicolumn{1}{l}{\textbf{4}} & 
    \multicolumn{1}{l}{\textbf{5}} & 
    \multicolumn{1}{l}{\textbf{6}} & 
    \multicolumn{1}{l}{\textbf{7}} & 
    \multicolumn{1}{l}{\textbf{8}} \\ \hline 
    \endfirsthead
    \multicolumn{9}{c}%
    {{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
    \hline \multicolumn{1}{l}{\textbf{Stepper Motor}} & 
    \multicolumn{1}{l}{\textbf{1}} & 
    \multicolumn{1}{l}{\textbf{2}} & 
    \multicolumn{1}{l}{\textbf{3}} & 
    \multicolumn{1}{l}{\textbf{4}} & 
    \multicolumn{1}{l}{\textbf{5}} & 
    \multicolumn{1}{l}{\textbf{6}} & 
    \multicolumn{1}{l}{\textbf{7}} & 
    \multicolumn{1}{l}{\textbf{8}} \\ \hline 
    \endhead
    \hline \multicolumn{9}{|r|}{{Continued on next page}} \\ \hline
    \endfoot
    \hline \hline
    \endlastfoot
    % table context
    \textbf{Pin} &22&30&38&46&23&31&39&47 \\
    \textbf{Pin} &24&32&40&48&25&33&41&49 \\
    \textbf{Pin} &26&34&42&50&27&35&43&51 \\
    \textbf{Pin} &28&36&44&52&29&37&45&53 \\
    \hline
    \end{longtable}
\end{center}
After connecting the Arduino to the stepper motors as depicted in Figure \ref{fig:circuit_connection}, 
the programme is ready for execution.
\begin{figure}[H] %[H] "corresponds to start the figure Here" 
    \centering %alignment can be flushleft or flushright
    \captionsetup{labelsep=colon}
    \includegraphics[width=0.9\textwidth]{Image/Result/circuit_connection.jpg} 
    \caption[The circuit connection of Arduino and stepper motors]
    {\centering \textbf{The circuit connection of Arduino and stepper motors.}}
    \label{fig:circuit_connection}
\end{figure}
\noindent Users are required to sequentially input eight values of $\Delta S_1 \sim \Delta S_8$ to initiate 
the corresponding operation of the stepper motor. If the input is less than eight, the control system will 
not be executed. \\
According to Figure \ref{fig:arduino_code_display_1} in Appendix \ref{append:code_display}, the change volume 
of cables are input into the Arduino program for execution, with the input data series being $\boldsymbol{\Delta S}$ 
= [0, 0, -8, 8, -15, 15, 65, -65] (mm). The value of $\Delta S_i$ is always in pairs, e.g, two cables controlling 
the same unit should always have the opposite $\Delta S_i$ value, this is decided by the working principle of the 
manipulator. After conversion, the corresponding $Step_1 \sim Step_8$ is [0, 0, -521, 521, -978, 978, 4237, -4237] 
(steps), where the “-” sign represents counterclockwise steps. Afterwards, the stepping can be finished in certain 
time. The function \emph{Serial.print(motor.currentPosition())} can be utilized to check the steps of motors.\\
According to Figure \ref{fig:arduino_code_display_2} in Appendix \ref{append:code_display}, result of first testing 
is demonstrated, with all the motors are working appropriately. In this programme, all floating-point precision 
is taken to the $10^{-4}$ millimeter while the result printed on the monitor is $10^{-2}$ millimeter, 
which means that the accuracy of the result is acceptable.\\
Then, reset the motors, the motors went back to initial condition, which is $Step_1 \sim Step_8=0$. Repeat the 
motor stepping process, but this time, the motors are starting from a previous location from
$\boldsymbol{\Delta S_{now}}$ = [0, 0, -8, 8, -15, 15, 65, -65] (mm) to $\boldsymbol{\Delta S_{next}}$ = 
[33, -33, 16, -16, 0, 0, 10, -10] (mm). The difference $\boldsymbol{\Delta S_{diff}}$ = 
[33, -33, 24, -24, 15, -15, -55, 55] (mm), while the steps for motors are 
[2151, -2151, 1565, -1565, 978, -978, -3585, 3585] (steps). The result can be verified by checking how many 
revolutions each motors rotated in Figure \ref{fig:arduino_code_display_3} in Appendix \ref{append:code_display}.
The results are aligned with the calculation. Hence, the actuation control system runs correctly.
The Arduino programme is updated in GitHub repository in 
\href{https://github.com/yezehao/Compact-Continuum-Manipulator-Platform/tree/main/Arduino-Simulation}
{Arduino Simulation}. \\
Overall, the method of using Arduino to control the stepper motor and drive the manipulator is a feasible solution. 
Although the initial idea of using simulation software failed to yield satisfying results, the testing outcomes with 
real components solved this problem.\\
Additionally, from the perspective of test results, it can be observed that the precisions of the stepper motors are 
very high, which is a great advantage for an open-loop (no feedback) system as it minimizes errors to the greatest 
extent. In the 28YBJ-48 motor parameter settings, full stepping configuration implies that the motor is divided into 
2048 steps per revolution. For a rotor driving a cable with a circumference of 31.416mm, this means a resolution of 
0.01534mm per step, which is enough to provide the accuracy required.\\
However, at the same time, there are some limitations to consider in this aspect. The most apparent limitation is that 
when cables wrap around the rotor, it effectively increases the diameter of the rotor, leading to some errors. For a 
cable with a total length of 68mm, it can wrap around the rotor twice. Assuming the cable has a thickness of 1mm, this 
would introduce a maximum error of approximately $ 31.416 / (31.416 + 2) = 0.05 $. Although in practice, it is unlikely 
that two layers of cable would perfectly stack on top of each other, this should be considered, because it's a factor 
that will cause errors. To solve this, an equation relating the length change of cables and the change in diameters 
should be deduced and applied in the program to minimize the potential error, but due to limited time, this part was 
not finished.\\
Furthermore, in this programme, only a rough setting for the step speed of the motors has been set. However, for 
achieving synchronization in starting/ending movement of each unit of the manipulator, more precise mathematical 
derivations for the speed of motors are required. In the following development process, it would be helpful to 
associate the speed of stepper motors with the distance to the target position, thereby dynamically setting a 
speed value for each motor to accomplish this synchronization. \\
Ultimately, the input parameters of the control system are $\boldsymbol{\Delta S}$, which consist of eight indices. 
It is inconvenient for users to input a series of indices. The Arduino programme can be optimized to taken the 
angles $\boldsymbol{\theta}$ as input paramters, which only require the users to input four parameters. The Python 
version programme is uploaded in the GitHub and ready to be converted into Arduino programme.\\



% change to new page
\newpage